# 1. 상속

## 상속

- 기존 클래스의 속성과 메서드를 물려받아 새로운 하위 클래스를 생성하는 것.
- 코드 재사용
    - 상속을 통해 기존 클래스의 속성과 메서드를 재사용할 수 있음
    - 클래스 간의 계층 구조 형성화 가능
    - 기존 클래스의 수정이 필요한 경우, 해당 클래스만 수정하면 되므로 유지 보수가 용이해짐

### 클래스 상속

- 학생/교수 정보를 별도로 표현하기 어려움
- 교수/학생 클래스로 분리 했지만 메서드가 중복으로 정의될 수 있음.

### 다중 상속

- 부모 클래스가 둘 이상.
- 중복된 속성이나 메서드가 있는 경우 상속 순서에 의해 결정됨
- 다이아몬드 문제를 해결하기 위해 MRO(Method Resolution Order) 알고리즘 사용하여 클래스 목록 생성
- super() : 부모 클래스 객체를 반환하는 내장 함수
    - 다중 상속 시 MRO를 기반으로 현재 클래스가 상속하는 모든 부모 클래스 중 다음에 호출될 메서드를 결정하여 자동으로 호출.
    - 복잡해질 경우 super()를 사용하여 상위 클래스 생각하지 않고도 자연스럽게 가져올 수 있도록 함.
    - 첫번째 부모 클래스에 __init__ 없으면 다음 클래스로 넘어감.
    - 단일 상속 구조에서 super사용 사례
        - 명시적으로 이름 지정하지 않고 부모 클래스 참조할 수 있으므로, 코드 유지 관리 쉬움
    - 다중 상속 구조에서 super 사용 사례
        - MRO를 따른 메서드 호출
        - 복잡한 다중 상속 구조에서 발생할 수 있는 문제 방지
- mro() 메서드
    - 해당 인스턴스의 클래스가 어떤 부모 클래스를 가지는지 확인하는 메서드
    - 기존의 인스턴스 →클래스 순으로 이름 공간을 탐색하는 과정에서 상속 관계에 있으면 인스턴스 → 자식 클래스 → 부모 클래스로 확장.
    - 참조 순서 궁금할 때 사용하는 메서드

# 2. 에러와 예외

# 디버깅

## 버그

- 소프트웨어에서 발생하는 오류 또는 결함, 프로그램의 예상된 동작과 실제 동작 사이의 불일치

## 디버깅

- 소프트웨어에서 발생하는 버그를 찾아내고 수정하는 과정
- print함수 활용
    - 특정 함수 결과, 반복/조건 결과 등 나눠서 생각, 코드를 bisection으로 나눠서 생각
- 개발환경 등에서 제공하는 기능 활용
    - breakpoint, 변수 조회 등
- Python tutor 활용(단순 파이썬 코드인 경우)

# 에러

- 프로그램 실행 중에 발생하는 예외 상황

## 문법 에러

- 프로그램의 구문이 올바르지 않은 경우 발생(오타, 괄호 및 콜론 누락 등의 문법적 오류)
- invalid syntax(문법오류)
- assign to literal(잘못된 할당)
- EOL(End of Line) : 문장을 끝내지 않은 경우
- EOF (End of File) : 파일명을 넣지 않은 경우?

# 예외

- 프로그램 실행 중에 감지되는 에러

### 내장예외

- 예외 상황을 나타내는 예외 클래스들
- ZeroDivisionError : 나누기 또는 모듈로 연산의 두번째 인자가 0일때 발생
- NameError : 지역 또는 전역 이름을 찾을 수 없을 때
- TypeError : 타입 불일치, 인자 누락, 인자 초과, 인자 타입 불일치
- ValueError : 연산이나 함수에 문제가 없지만 부적절한 값을 가진 인자를 받았고, 상황이 IndexError 처럼 더 구체적인 예외로 설명되지 않는 경우 발생
- IndexError : 시퀀스 인덱스가 범위를 벗어날 때 발생
- KeyError: 딕셔너리에 해당 키가 존재하지 않는 경우
- ModuleNotFoundError: 모듈을 찾을 수 없을 때 발생
- ImportError: import하려는 이름을 찾을 수 없을 때
- KeyboardInterrupt: 사용자가 Control-C또는 Delete를 누를 때 발생, 무한루프 강제종료
- IndentationError: 잘못된 들여쓰기와 관련된 문법 오류

### 예외 처리

- try : 예외가 발생할 수 있는 코드 작성
- except : 예외가 발생했을 때 실행할 코드 작성
- else : 예외가 발생하지 않았을 때 실행할 코드 작성
- finally : 예외 발생 여부와 상관없이 항상 실행할 코드 작성

### 예외 처리 주의사항

- 계층 구조가 낮은 하위 클래스에서 먼저 확인할 수 있도록 작성해야됨.

### 예외 객체 다루기

- as 키워드 : 예외가 발생했을 때 예외에 대한 정보를 담고 있는 객체
- except 블록에서 예외 객체를 받아 상세한 예외 정보 활용 가능

```
my_list = []

try:
    number = my_list[1]
except IndexError as error:
    # list index out of range가 발생했습니다.
    print(f'{error}가 발생했습니다.')
```

### EAFP

- “Easier to Ask for Forgiveness than Permission”
- 예외처리를 중심으로 코드를 작성하는 접근 방식(try-except)
- 일단 지른다.

### LBYL

- “Look Before You Leap”
- 값 검사를 중심으로 코드를 작성하는 접근 방식(if-else)